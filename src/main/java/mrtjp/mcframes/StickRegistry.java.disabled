package mrtjp.mcframes;


import com.google.common.collect.Sets;
import mrtjp.mcframes.api.IFrameInteraction;
import net.minecraft.block.Block;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class StickRegistry {

    Pattern rKeyVal = Pattern.compile("([\\w:]+)\\s*->\\s*(.+)");
    Pattern rName = Pattern.compile("(.+)");
    Pattern rNameMetaM = Pattern.compile("(.+)m(\\d+)");
    Pattern rMod = Pattern.compile("mod:(\\w+)");

    // Default value is an empty set
    Map<Pair<Block, Integer>, Set<Pair<Block, Integer>>> latchMap = new HashMap<>();
    List<IFrameInteraction> interactionList = new ArrayList<>();

    public List<Pair<String, String>> parseKV(List<String> kv) {
        return kv.stream().map(s -> {
            Matcher m = rKeyVal.matcher(s);
            if (!m.find()) throw new RuntimeException("Illegal [k -> v] pair: " + s);
            return new ImmutablePair<>(m.group(1), m.group(2));
        }).collect(Collectors.toList());
    }

    public Pair<Block, Integer> parseBlockMeta(String b) {
        Matcher m = rNameMetaM.matcher(b);
        if (m.find())
            return new ImmutablePair<>(Block.getBlockFromName(fixName(m.group(1)), Integer.parseInt(m.group(2))));

        m = rName.matcher(b);
        if (m.find())
            return new ImmutablePair<>(Block.getBlockFromName(fixName(m.group(1)), -1));

        throw new RuntimeException("Illegal set part: " + b);
    }

    public String fixName(String name) {
        int i = name.indexOf(':');
        if (i == -1) {
            return "minecraft:" + name;
        }
        return name;
    }

    public List<String> parseAndAddLatchSets(List<String> kv) {
        parseKV(kv).stream().map(b ->
            addLatchSet(parseBlockMeta(b.getLeft()), parseBlockMeta(b.getRight())));
        latchMap
            .map { kv =>
            val (b, i) = kv._1
            val e1 = Block.blockRegistry.getNameForObject(b) + (if (i != -1) s"m$i"
                                                            else "")
            kv._2.map { k =>
                val (b2, i2) = k
                val e2 =
                    Block.blockRegistry.getNameForObject(b2) + (if (i2 != -1) s"m$i2"
                                                        else "")
                e1 + " -> " + e2
            }
        }
      .flatten
            .toArray
    }

    public void addLatchSet(Pair<Block, Integer> b1, Pair<Block, Integer> b2) {
        latchMap.put(new ImmutablePair<>(b1, new HashSet<>(Arrays.asList(latchMap.get(b1), b2))));
    }

    def resolveStick(w: World, pos: BlockCoord, side: Int): Boolean = {
        def getFrame(pos: BlockCoord): IFrame = {
            val b = getBlock(w, pos)
        if (b.isInstanceOf[IFrame]) return b.asInstanceOf[IFrame]
        val te = getTileEntity(w, pos, classOf[IFrame])
        if (te != null) return te
        interactionList.find(_.canInteract(w, pos.x, pos.y, pos.z)).orNull
    }

        val f1 = getFrame(pos)
        if (f1 != null && f1.stickOut(w, pos.x, pos.y, pos.z, side)) {
            val p2 = pos.copy.offset(side)
            val f2 = getFrame(p2)
            return f2 == null || f2.stickIn(w, p2.x, p2.y, p2.z, side ^ 1)
        }

        if (latchSet(w, pos.x, pos.y, pos.z, side)) return true

        false
    }

    def latchSet(w: World, x: Int, y: Int, z: Int, side: Int) = {
        val pos = new BlockCoord(x, y, z).offset(side)
        val b1 = getBlockMetaPair(w, x, y, z)
        val b2 = getBlockMetaPair(w, pos.x, pos.y, pos.z)

        val set = latchMap.getOrElse(b1, latchMap((b1._1, -1)))
        set.contains(b2) || set.contains((b2._1, -1))
    }
}
